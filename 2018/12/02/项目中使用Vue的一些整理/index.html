<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Xiaoqi&#39;s blog</title>
<!--   <link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah" rel="stylesheet"> -->
  <!-- theme为主题的config.yml -->
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/Graffiti.css">
    
  
</head>
<body>

<!-- 导航栏 -->
<!-- 导航栏部分 -->
<div id="navigationBar-bg" class="navigationBar-bg" style="background: url('/img/navigationBar.jpg') no-repeat;">
  <div id="navigationBar-content" class="navigationBar-content">
    <div class="personal-block">
      <div class="portrait">
        <div class="portrait-background">
          <div class="portrait-img" style="background: url('/img/portrait.jpg') no-repeat; background-size: 100%"></div>
        </div>
      </div>
      <div class="nickname"><span>Xiaoqi&#39;s blog</span></div>
    </div>

    <div class="navigationBar-menu">
      
        <li>
          <div class="menu-hover Home-hover"></div>
          <a id="Home" href="/">Home</a>
        </li>
      
        <li>
          <div class="menu-hover Archives-hover"></div>
          <a id="Archives" href="/archives">Archives</a>
        </li>
      
        <li>
          <div class="menu-hover Tags-hover"></div>
          <a id="Tags" href="/tags">Tags</a>
        </li>
      
        <li>
          <div class="menu-hover Github-hover"></div>
          <a id="Github" href="https://github.com/Qxiaoqi">Github</a>
        </li>
      
    </div>
  </div>
</div>

<!-- layout渲染部分 -->
<div id="content-outer" class="content-outer">
  <div class="content-margin">
    <div id="content-inner" class="content-inner">
      
<article id="post" class="post">
	<div class="post-title">
  		<span class="post-title-link">项目中使用Vue的一些整理</span>
	</div>
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又是很久都没有整理过了，这次也不立什么一定要坚持写博客的flag了。这一段时间忙了一些别的事情，技术上把Vue全家桶用于项目中实践了一下，也算是收获不少。</p>
<a id="more"></a>
<h2 id="大概需求"><a href="#大概需求" class="headerlink" title="大概需求"></a>大概需求</h2><p>先放一张大概效果图。</p>
<p><img src="/assets/2018-12-2/picture.jpg"></p>
<p>需求简单点讲就是学科期刊，以及热点论文什么的查询。内容上分为六个模块，其中一个ESI学科期刊模块，两个顶级论文模块内容基本一样。查询时左侧会分别用关键词、月份、年份、学科进行过滤。然后还要支持导出excel，就是把数据整合成excel表格导出。</p>
<p>需求并不是很复杂，但是实际写的时候确实也是考虑了很多东西，算是在代码规范上更近了一步吧。</p>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="组件抽象"><a href="#组件抽象" class="headerlink" title="组件抽象"></a>组件抽象</h3><p>学科期刊和顶级论文这三个模块内容基本一致，返回数据不同，因此可以把他们归为一类。</p>
<h4 id="左侧过滤组件"><a href="#左侧过滤组件" class="headerlink" title="左侧过滤组件"></a>左侧过滤组件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FilterForm</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">"isRenderTime"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">filterType</span>=<span class="string">"timeMonth"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"checkedMonth"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:filterItems</span>=<span class="string">"formData.filterMonth"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">give-conditions</span>=<span class="string">"getArticaleData"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">FilterForm</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>左侧抽象出来过滤组件，其中关键词查询都有不用做过多抽象。</p>
<p>分类检索部分分三块，也可以抽象成一个小的过滤组件。通过父级组件传值<code>filterType</code>，来确定渲染成哪一部分的过滤模块</p>
<p>其中由于月份的显示方式不太一样，为了节省空间，一行放了两个。所以需要绑定一个特殊的class，再用一个计算属性<code>isMonth</code>来判断是否是月份过滤，来判断有<code>display: inline-block</code>的class是否显示该组件上</p>
<p>月份、年份、学科这三个过滤条件并不是每个页面都需要，因此根据获取的路由数据来判断哪一个过滤条件需要显示</p>
<p>由于点击一个过滤按钮，需要获取其所有兄弟过滤组件的选中数据，所以这里我通过在过滤组件点击时，向父级元素传递信号，然后在父级元素上通过ref获取了三个过滤组件的值。</p>
<h3 id="vuex数据管理"><a href="#vuex数据管理" class="headerlink" title="vuex数据管理"></a>vuex数据管理</h3><p>把Vuex的相关代码分割成了数个模块，便于管理。然后提交方式都是通过action异步提交（这样更规范一些？此处后面还需要深入理解一下）</p>
<p>查询里面的条件全部都用了Vuex来管理，<code>关键词</code>、<code>页码</code>、<code>月份</code>、<code>年份</code>、<code>学科</code>（此处可能还需要深入思考一下，<code>关键词</code>、<code>月份</code>、<code>年份</code>、<code>学科</code>这四个确实还有别的兄弟组件渲染的时候需要使用，但仅仅是读取并不会修改，放在Vuex里面管理代码方便了很多，但是究竟有没有更合适的方法还需要深入思考一下。但是<code>页码</code>这个并没有别的组件需要共享，放在里面纯属是因为和后台传参的时候直接读取Vuex的数据就行，图个方便，是否合理确实还要三思一下）</p>
<p>搜索结果，就是后端传回来的文章数据，我也把他放在了Vuex里面管理。当时想的是，获取结果有四种方式，分别是<code>页面跳转</code>、<code>关键词查询</code>、<code>过滤条件</code>、<code>页码</code>这四个部分需要从后端获取数据，后端返回数据以后直接分发提交到Vuex里面，然后页面直接响应式渲染出来（其实也是图个方便，而且也确实目前的水准想不出什么更好的方式来组织结构）。</p>
<p>文章下载全选功能，这个应该是用的比较的合适了。就是点击全选后，所有文章前面的多选框都要确定上，然后若某一个多选框取消了，全选前面的框也要取消。从这个角度看，双方共同维护这个选中的文章数组，两方都是可读可写，此处用的应该可以说是非常合适了。</p>
<p>因此，总结一下，Vuex用了之后非常的方便，但是也可能造成一些Vuex的滥用，目前也确实没有想到比较好的方式来管理，此处需要在项目结束之后深入思考一下。</p>
<h2 id="关于css"><a href="#关于css" class="headerlink" title="关于css"></a>关于css</h2><h3 id="css嵌套问题"><a href="#css嵌套问题" class="headerlink" title="css嵌套问题"></a>css嵌套问题</h3><p>之前为了图方便，往往把子元素都写在其父元素内，导致父元素的class拉的很长，这样一是不便查看，二是不便于组件复用（只有位于特定父元素下，该class才会生效，不便于复用）。<br>重构后，发现代码可读性并不是很高。于是再次重构，将联系紧密的嵌套一起，嵌套层数不超过2层，感觉可读性更强了一些。</p>
<p>还有css不要嵌套选择器，比如说导航  .list a  ，像这样可能会导致后面改动的问题，比如说list内又加了一个item，item里加了一个a，这时候就会影响到item a，不便于维护。</p>
<h3 id="将less的全局变量文件抽离"><a href="#将less的全局变量文件抽离" class="headerlink" title="将less的全局变量文件抽离"></a>将less的全局变量文件抽离</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深灰</span></span><br><span class="line">@deep-grey: #e6e6e6;</span><br><span class="line"><span class="comment">// 浅灰</span></span><br><span class="line">@light-grey: #F1F1F1;</span><br><span class="line"><span class="comment">// 深色边框</span></span><br><span class="line">@border-deep: #bababa;</span><br><span class="line"><span class="comment">// 浅色边框</span></span><br><span class="line">@border-light: #d3d3d3;</span><br><span class="line"><span class="comment">// header底色</span></span><br><span class="line">@header-blue: #2a4c90;</span><br><span class="line"><span class="comment">// 字体颜色</span></span><br><span class="line">@font-color: #4b505a;</span><br><span class="line"><span class="comment">// 搜索结果面板背景</span></span><br><span class="line">@content-color: #f8f8f8;</span><br><span class="line"><span class="comment">// 按钮颜色</span></span><br><span class="line">@button-color: #e4e5ec;</span><br></pre></td></tr></table></figure>
<p>为了方便项目颜色的调整，很多时候取的颜色都是相同的，这里可以使用less的变量定义。但是这里如果每个vue文件都要引入一遍less文件，会很麻烦，也不方便维护。这里使用<code>style-resources-loader</code>插件来管理，npm安装好后，在vue.config.js里面配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    <span class="comment">// 配置less全局变量</span></span><br><span class="line">    <span class="string">"style-resources-loader"</span>: &#123;</span><br><span class="line">      preProcessor: <span class="string">"less"</span>,</span><br><span class="line">      patterns: [path.resolve(__dirname, <span class="string">"src/global.less"</span>)]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>配置好后，就可以直接在每个vue中使用了（此处需要研究一下原理）。</p>
<h2 id="axios二次封装"><a href="#axios二次封装" class="headerlink" title="axios二次封装"></a>axios二次封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="comment">// import qs from "qs"; // 序列化请求数据，视服务端的要求</span></span><br><span class="line"><span class="comment">// import router from "../router";</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Axios = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">"http://106.14.153.164:6374"</span>,</span><br><span class="line">  timeout: <span class="number">10000</span>,</span><br><span class="line">  responseType: <span class="string">"json"</span>,</span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// 是否允许带cookie这些</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json;charset=utf-8"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//POST传参序列化(添加请求拦截器)</span></span><br><span class="line">Axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做某件事</span></span><br><span class="line">    <span class="comment">// if (config.method === "post") &#123;</span></span><br><span class="line">    <span class="comment">//   // 序列化</span></span><br><span class="line">    <span class="comment">//   config.data = qs.stringify(config.data);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若是有做鉴权token , 就给头部带上token</span></span><br><span class="line">    <span class="comment">// 若是需要跨站点,存放到 cookie 会好一点,限制也没那么多,有些浏览环境限制了 localstorage 的使用</span></span><br><span class="line">    <span class="comment">// 这里localStorage一般是请求成功后我们自行写入到本地的,因为你放在vuex刷新就没了</span></span><br><span class="line">    <span class="comment">// 一些必要的数据写入本地,优先从本地读取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里在api.js里面加了一个参数，控制是否需要传递鉴权</span></span><br><span class="line">    <span class="comment">// 当有requiresAuth且为true是加上鉴权</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      config.requiresAuth &amp;&amp;</span><br><span class="line">      config.requiresAuth === <span class="literal">true</span> &amp;&amp;</span><br><span class="line">      localStorage.loginUserBaseInfo &amp;&amp;</span><br><span class="line">      <span class="built_in">JSON</span>.parse(localStorage.loginUserBaseInfo).jwtCode</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">let</span> token = <span class="built_in">JSON</span>.parse(localStorage.loginUserBaseInfo).jwtCode;</span><br><span class="line">      config.headers.Authorization = token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"config:"</span>, config);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// error 的回调信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"request:"</span>, error);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回状态判断(添加响应拦截器)</span></span><br><span class="line">Axios.interceptors.response.use(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="comment">//对响应数据做些事</span></span><br><span class="line">    <span class="keyword">if</span> (res.data &amp;&amp; !(res.data.code === <span class="number">200</span>)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"返回状态判断"</span>);</span><br><span class="line">      <span class="comment">// console.log("res:", res);</span></span><br><span class="line">      alert(res.data.msg);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res.data.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"res:"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; error.response) &#123;</span><br><span class="line">      <span class="keyword">let</span> msg = error.response.data.msg;</span><br><span class="line">      <span class="keyword">switch</span> (error.response.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">          alert(<span class="string">"请求错误："</span> + msg);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          alert(<span class="string">"未经授权的"</span> + msg);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">          alert(<span class="string">"拒绝访问"</span> + msg);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">          alert(<span class="string">"请求地址出错"</span> + msg);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">          alert(<span class="string">"服务器内部错误"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          alert(<span class="string">"错误"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"response:"</span>, error.response);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Axios;</span><br></pre></td></tr></table></figure>
<p>这里由于每次请求分到各个逻辑里面处理的话，代码不好管理，而且代码会很乱，工作量也大。这里把axios做一个二次封装，做一个请求和相应的统一拦截。</p>
<p>比如说很多请求（除了登录）都需要鉴权验证，在请求前做一个请求头统一加上Authorization。然后也可以设置一下统一的<code>Content-Type</code>，这里需要和后端协商一下，让他统一接收参数或者json。如果接收参数的话，也可以使用qs做一个统一序列化。</p>
<p>然后可以共同约定一下返回的错误code，然后把返回的code值根据约定作相应的处理，比如说401鉴权失败，然后重定向到<code>/login</code></p>
<p>然后也可以把接口统一封装一下，便于修改</p>
<p>然后如果想要在全局使用这个封装好的api，在main.js中引入api文件，然后使用<code>Vue.prototype.$api = api;</code>，(这里应该是把$api放到了Vue的原型上)，就可以在全局通过<code>this.$api</code>调用了</p>
<h2 id="JWT鉴权验证"><a href="#JWT鉴权验证" class="headerlink" title="JWT鉴权验证"></a>JWT鉴权验证</h2><p>JWT之前一直没用过，这次和后端用了一下，在前后端分离里面用的比较多吧。</p>
<p>那么鉴权验证的流程是什么呢？简单讲就是，前端用户登陆后，后端会返回一个token，然后前端把这个token存到localStorage或者session再或者Vuex里面管理，不同位置有不同的适用范围吧。考虑到session以及Vuex里面管理的话，刷新后就没有了，所以我存到了localStorage里面。</p>
<p>然后每次需要鉴权的时候（比如说这里面的查询就需要鉴权，但是登陆不需要鉴权），把token加到请求头里面，发给后端进行身份验证。然后后端返回code状态码，或者直接重定向什么的都行。</p>
<p>JWT按照我的理解主要用于签名验证，JWT分为三段，验证前两段编码后和第三段是否相同，即可判断是否是目标签名。</p>
<h3 id="具体的一些实现"><a href="#具体的一些实现" class="headerlink" title="具体的一些实现"></a>具体的一些实现</h3><h4 id="axios拦截"><a href="#axios拦截" class="headerlink" title="axios拦截"></a>axios拦截</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  localStorage.loginUserBaseInfo &amp;&amp;</span><br><span class="line">  <span class="built_in">JSON</span>.parse(localStorage.loginUserBaseInfo).jwtCode</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">let</span> token = <span class="built_in">JSON</span>.parse(localStorage.loginUserBaseInfo).jwtCode;</span><br><span class="line">  config.headers.Authorization = token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我一开始把所有的请求都加上了token，这里就是做一个简单的判断，判断本地有没有保存token信息，保存的话就加到请求头里面。</p>
<p>但是后来有一个问题，那就是比如登录并不需要加上token，虽然后端没有判断，一开始并没有什么问题。但是当超过了过期时间之后，我发现登录的时候有莫名的报错，看了好半天才找到了这个问题。那就是后端应该是把这个鉴权统一处理了，那只能我这边来改。</p>
<p>解决方法，在封装过的api请求文件里面，多加上一个参数<code>requiresAuth</code>为<code>true</code>则表示需要鉴权。然后在axios拦截器里面多加上一个判断<code>config.requiresAuth &amp;&amp; config.requiresAuth === true</code>（<del>此处需要深入理解一下Promise和ajax的区别</del>）</p>
<p>Promise主要用于异步编程，和ajax并无联系，只不过是因为Promise用于ajax异步后，能解决回调地狱问题，更多实践查看<a href="/2019/02/18/js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">js异步编程</a></p>
<h4 id="vue-router全局导航守卫"><a href="#vue-router全局导航守卫" class="headerlink" title="vue-router全局导航守卫"></a>vue-router全局导航守卫</h4><p>这里每次跳转前都要做一个判断，就是判断当前是否有鉴权信息，以及是否过期</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue-router导航守卫，全局守卫</span></span><br><span class="line"><span class="comment">// 并不是所有页面请求都需要加上token，所以需要做一个全局守卫</span></span><br><span class="line"><span class="comment">// 在路由meta加一个字段requiresAuth,设置为true则必须加上鉴权</span></span><br><span class="line"><span class="comment">// 登录页不需要鉴权</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果检测到meta含有字段</span></span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">res</span> =&gt;</span> res.meta.requiresAuth)) &#123;</span><br><span class="line">    <span class="comment">// 检测是否有鉴权信息</span></span><br><span class="line">    <span class="keyword">if</span> (localStorage.loginUserBaseInfo) &#123;</span><br><span class="line">      <span class="keyword">let</span> lifeTime = <span class="built_in">JSON</span>.parse(localStorage.loginUserBaseInfo).lifeTime;</span><br><span class="line">      <span class="keyword">let</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">      <span class="comment">// 比较当前时间和过期时间</span></span><br><span class="line">      <span class="keyword">if</span> (nowTime &lt; lifeTime) &#123;</span><br><span class="line">        <span class="comment">// 有鉴权信息而且未过期</span></span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 鉴权已过期，跳转到登录页</span></span><br><span class="line">        alert(<span class="string">"登录状态过期，请重新登录"</span>);</span><br><span class="line">        next(&#123;</span><br><span class="line">          path: <span class="string">"/login"</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有鉴权信息，跳转到登录页</span></span><br><span class="line">      alert(<span class="string">"登录状态过期，请重新登录"</span>);</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: <span class="string">"/login"</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 无需鉴权信息，继续</span></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于后端返回的过期时间是时间段，所以这里判断过期采用的方法是，login登录后获取的过期时间加上<code>getTime()</code>，得到过期时间戳存入localStrage。然后在路由处设置meta字段，来控制路由跳转时是否需要鉴权判断过期时间，如果过期，直接跳转到<code>/login</code>。</p>
<h2 id="二进制流文件下载"><a href="#二进制流文件下载" class="headerlink" title="二进制流文件下载"></a>二进制流文件下载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(response.headers);</span><br><span class="line"><span class="keyword">let</span> content = response.data;</span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([content]);</span><br><span class="line"><span class="keyword">let</span> fileName = response.headers[<span class="string">"content-disposition"</span>].split(<span class="string">"="</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"download"</span> <span class="keyword">in</span> <span class="built_in">document</span>.createElement(<span class="string">"a"</span>)) &#123;</span><br><span class="line">  <span class="comment">// 非IE下载</span></span><br><span class="line">  <span class="keyword">let</span> elink = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">  elink.download = fileName;</span><br><span class="line">  elink.style.display = <span class="string">"none"</span>;</span><br><span class="line">  elink.href = URL.createObjectURL(blob);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(elink);</span><br><span class="line">  elink.click();</span><br><span class="line">  URL.revokeObjectURL(elink.href);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// IE 10+ 下载</span></span><br><span class="line">  navigator.msSaveBlob(blob, fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里后端传我的是二进制流，虽然之前写的项目也是这样处理的，但是一个是当时没有认真研究，而且当时没有使用axios，导致这次也卡了一小段时间。</p>
<p>然后就是Blob对象，Blob 对象表示一个不可变、原始数据的类文件对象。这里创建了一个文本节点，并隐藏，触发点击事件，触发下载。而且需要把api封装的接口设置<code>responseType: &quot;blob&quot;</code>。</p>
<p>这里获取的是excel文件，后端通过<code>Content-Disposition</code>把文件名返回给我，这里其实有一个问题。虽然从network里面分析到了该请求头，但是axios并没有拦截到该请求头，这里需要后端设置<code>Access-Control-Expose-Headers</code>才能获取到该请求头。</p>
<p>但是目前有一个问题还没有解决，那就是后端直接返回我的是<code>data: Blob()</code>，似乎是不能再多返回一个code状态码？没有状态码的话，我前面axios的拦截就不能统一根据返回的code来采取不同的处理。这里暂时没有解决，后面需要尝试写一下后端研究一下。</p>
<p>（……未完待续，项目还没写完，有时间再整理）</p>

</article>



    </div>

    <!-- footer部分 -->
    <!-- footer部分 -->
<div id="footer-outer" class="footer-outer">
  <div id="footer-inner" class="footer-inner">
    <span class="footer-left">© Xiaoqi </span>
    <span class="footer-right">Hexo Theme Graffiti by Xiaoqi</span>
  </div>
</div>  
  </div>

</div>



  <!-- scripts list from theme config.yml -->
  
    <script src="/js/jquery-3.2.1.js"></script>
  
    <script src="/js/graffiti.js"></script>
  


</body>
</html>
